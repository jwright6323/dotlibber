#!/usr/bin/env python

import re
import json
import sys
from datetime import datetime

# Define how many spaces are in an indentation
IWIDTH = 4

class Lib:

    def __init__(self, attr):
        self.attr = attr
        self.name = get_name(self)
        self.datetime = datetime.now().strftime("%c")
        require_int(self,"revision")
        # TODO corner stuff
        require_key(self,"cells")
        self.cells = []
        for a in self.attr["cells"]:
            self.add_cell(a)

    def add_cell(self, cell_attr):
        self.cells.append(Cell(self, cell_attr))



    def emit(self):
        output  = "library (%s) {\n" % self.name
        header  = "technology (cmos);\n"
        # Assert that we're only doing NLDM
        header += "delay_model : table_lookup;\n"
        header += "date : \"%s\";\n" % self.datetime
        header += "comment : \"Generated by dotlibber.py\";\n"
        header += "revision : %s;\n" % self.attr["revision"]
        header += "simulation : true;\n"
        # Here are a bunch of unit specs that nobody ever changes.
        header += "capacitive_load_unit : \"1pF\";\n"
        header += "voltage_unit : \"1V\";\n"
        header += "current_unit : \"1mA\";\n"
        header += "time_unit : \"1ns\";\n"
        header += "pulling_resistance_unit : \"1kohm\";\n"
        # TODO emit cells
        output += indent(header)
        output += "\n"
        for c in self.cells:
            output += indent(c.emit())
            output += "\n"

        output += "}\n"
        return output



class Cell:

    def __init__(self, lib, attr):
        self.lib = lib
        self.attr = attr
        self.name = get_name(self)
        require_key(self, "pg_pins")
        require_key(self, "pins")
        self.pg_pins = []
        self.pins = []
        for p in self.attr["pg_pins"]:
            self.add_pg_pin(p)
        for p in self.attr["pins"]:
            self.add_pin(p)

    def power_pins(self):
        return filter(lambda x: x.type == "primary_power", self.pg_pins)

    def ground_pins(self):
        return filter(lambda x: x.type == "primary_ground", self.pg_pins)

    def add_pg_pin(self, pg_pin_attr):
        self.pg_pins.append(PGPin(self, pg_pin_attr))

    def add_pin(self, pin_attr):
        self.pins.append(Pin(self, pin_attr))


    def emit(self):
        output  = "cell (%s) {\n" % self.name
        # For now, always dont_touch, dont_use macros. We aren't using this for std cells.
        output += indent("dont_use : true;\n")
        output += indent("dont_touch : true;\n")
        output += indent("is_macro_cell : true;\n")
        for p in self.pg_pins + self.pins:
            output += "\n"
            output += indent(p.emit())
        output += "}\n"
        return output

class Pin:

    def __init__(self, cell, attr):
        self.cell = cell
        self.attr = attr
        self.name = get_name(self)
        require_values(self, "direction", ["input", "output", "inout"])
        optional_values(self, "is_analog", ["true", "false"], "false")
        # Digital pin checks
        if self.attr["is_analog"] == "false":
            if self.attr["direction"] == "inout":
                sys.stderr.write("Digital inout pins are not supported. FIXME. Aborting\n")
                exit(1)
            require_float(self, "capacitance")
            # Assert that we must have a power pin with the name in our PG pin list
            require_values(self, "related_power_pin", map(lambda x: x.name, self.cell.power_pins()))
            # Assert that we must have a ground pin with the name in our PG pin list
            require_values(self, "related_ground_pin", map(lambda x: x.name, self.cell.ground_pins()))


    def has_attr(self, attr):
        return attr in self.attr.keys()

    # TODO emit timing arcs
    def emit(self):
        output  = "pin (%s) {\n" % self.name
        for k in self.attr:
            output += "    %s : %s;\n" % (k, self.attr[k])
        output += "}\n"
        return output


class PGPin:

    def __init__(self, cell, attr):
        self.cell = cell
        self.attr = attr
        self.name = get_name(self)
        # For now only implement primary power/ground. If anyone needs secondary power/ground, you get to update this!
        require_values(self, "pg_type", ["primary_power", "primary_ground"])
        self.type = self.attr["pg_type"]

    def emit(self):
        output = "pg_pin (%s) {\n" % self.name
        output += indent("pg_type : %s;\n" % self.type)
        # For now assert that voltage_name is the same as the pin name
        output += indent("voltage_name : %s;\n" % self.name)
        output += "}\n"
        return output



def get_name(obj):
    if "name" not in obj.attr.keys():
        sys.stderr.write("Missing name for %s object. Aborting.\n" % obj.__class__.__name__)
        exit(1)
    return obj.attr["name"]

def require_key(obj, key):
    if key not in obj.attr.keys():
        sys.stderr.write("Missing required key \"%s\" for %s object %s. Aborting.\n" % (key, obj.__class__.__name__, obj.name))
        exit(1)

def require_values(obj, key, values):
    require_key(obj, key)
    if obj.attr[key] not in values:
        sys.stderr.write("Invalid entry \"%s\" for attribute \"%s\" of %s object %s. Allowed values are %s. Aborting.\n" % (obj.attr[key], key, obj.__class__.__name__, obj.name, ', '.join(values)))
        exit(1)

def optional_values(obj, key, values, default=None):
    if key in obj.attr:
        require_values(obj, key, values)
    else:
        if default is not None:
            obj.attr[key] = default
            require_values(obj, key, values)

def try_convert_float(obj, key):
    require_key(obj, key)
    try:
        return float(obj.attr[key])
    except:
        sys.stderr.write("Invalid entry %s for attribute %s of %s object %s. Must be a float. Aborting.\n" % (obj.attr[key], key, obj.__class__.__name__, obj.name))
        exit(1)

def try_convert_int(obj, key):
    require_key(obj, key)
    try:
        return int(obj.attr[key])
    except:
        sys.stderr.write("Invalid entry %s for attribute %s of %s object %s. Must be a int. Aborting.\n" % (obj.attr[key], key, obj.__class__.__name__, obj.name))
        exit(1)

def require_float(obj, key):
    try_convert_float(obj, key)

def require_int(obj, key):
    try_convert_int(obj, key)

# TODO don't indent empty lines
def indent(s, lvl=1):
    return re.compile('^([^$])',re.MULTILINE).sub(" " * IWIDTH * lvl + "\\1", s)


def __main__():
    filename = "../conf/test.json"
    try:
        attr = json.load(file(filename))
    except:
        sys.stderr.write("Syntax error parsing JSON file %s. Aborting.\n" % filename)
        exit(1)
    lib = Lib(attr)
    print(lib.emit())

__main__()
