#!/usr/bin/env python

import re
import json
import sys
from datetime import datetime

# Define how many spaces are in an indentation
IWIDTH = 4

class Corner:

    def __init__(self, attr):
        self.attr = attr
        self.name = get_name(self)
        self.process = try_convert_int(self, "process")
        self.temperature = try_convert_int(self, "temperature")
        require_key(self, "voltage_map")
        require_float(self, "nominal_voltage")
        self.voltage = self.attr["nominal_voltage"]
        self.voltage_map = {}
        for k in self.attr["voltage_map"]:
            self.voltage_map[k] = float(self.attr["voltage_map"][k])

    def emit(self):
        output  = "nom_process : %d;\n" % self.process
        output += "nom_temperature : %d;\n" % self.temperature
        output += "nom_voltage : %f;\n" % self.voltage
        for k in self.voltage_map:
            output += "voltage_map(%s, %f);\n" % (k, self.voltage_map[k])
        output += "operating_conditions(\"%s\") {\n" % self.name
        output += indent("process : %d;\n") % self.process
        output += indent("temperature : %d;\n") % self.temperature
        output += indent("voltage : %f;\n") % self.voltage
        output += "}\n"
        output += "default_operating_conditions : %s;\n" % self.name
        return output

class Lib:

    def __init__(self, attr, corners):
        self.attr = attr
        self.name = get_name(self)
        self.datetime = datetime.now().strftime("%c")
        require_int(self,"revision")
        self.corners = []
        for c in corners:
            self.add_corner(c)
        require_key(self,"cells")
        self.cells = []
        for a in self.attr["cells"]:
            self.add_cell(a)

    def add_cell(self, cell_attr):
        self.cells.append(Cell(self, cell_attr))

    def add_corner(self, corner_attr):
        self.corners.append(Corner(corner_attr))

    def corner_name(self, corner):
        return self.name + "_" + corner.name

    def emit(self, corner):
        output  = "library (%s) {\n" % self.corner_name(corner)
        header  = "technology (cmos);\n"
        # Assert that we're only doing NLDM
        header += "delay_model : table_lookup;\n"
        header += "date : \"%s\";\n" % self.datetime
        header += "comment : \"Generated by dotlibber.py\";\n"
        header += "revision : %s;\n" % self.attr["revision"]
        header += "simulation : true;\n"
        # Here are a bunch of unit specs that nobody ever changes.
        header += "capacitive_load_unit : \"1pF\";\n"
        header += "voltage_unit : \"1V\";\n"
        header += "current_unit : \"1mA\";\n"
        header += "time_unit : \"1ns\";\n"
        header += "pulling_resistance_unit : \"1kohm\";\n"
        output += indent(header)
        output += indent(corner.emit())
        output += "\n"
        for c in self.cells:
            output += indent(c.emit())
            output += "\n"

        output += "}\n"
        return output


class Cell:

    def __init__(self, lib, attr):
        self.lib = lib
        self.attr = attr
        self.name = get_name(self)
        require_key(self, "pg_pins")
        require_key(self, "pins")
        self.pg_pins = []
        self.pins = []
        self.clocks = []
        for p in self.attr["pg_pins"]:
            self.add_pg_pin(p)
        for p in self.attr["pins"]:
            self.add_pin(p)

    def power_pins(self):
        return filter(lambda x: x.type == "primary_power", self.pg_pins)

    def ground_pins(self):
        return filter(lambda x: x.type == "primary_ground", self.pg_pins)

    def add_pg_pin(self, pg_pin_attr):
        self.pg_pins.append(PGPin(self, pg_pin_attr))

    def add_pin(self, pin_attr):
        self.pins.append(Pin(self, pin_attr))

    def add_clock(self, pin):
        self.clocks.append(pin)

    def emit(self):
        output  = "cell (%s) {\n" % self.name
        # For now, always dont_touch, dont_use macros. We aren't using this for std cells.
        output += indent("dont_use : true;\n")
        output += indent("dont_touch : true;\n")
        output += indent("is_macro_cell : true;\n")
        for p in self.pg_pins + self.pins:
            output += "\n"
            output += indent(p.emit())
        output += "}\n"
        return output

class Pin:

    def __init__(self, cell, attr):
        self.cell = cell
        self.attr = attr
        self.name = get_name(self)
        require_values(self, "direction", ["input", "output", "inout"])
        optional_values(self, "is_analog", ["true", "false"], "false")
        optional_values(self, "clock", ["true", "false"], "false")
        # Digital pin checks
        if self.attr["is_analog"] == "false":
            if self.attr["clock"] == "true":
                self.cell.add_clock(self)
            if self.attr["direction"] == "inout":
                sys.stderr.write("Digital inout pins are not supported. FIXME. Aborting\n")
                exit(1)
            require_float(self, "capacitance")
            # Assert that we must have a power pin with the name in our PG pin list
            require_values(self, "related_power_pin", map(lambda x: x.name, self.cell.power_pins()))
            # Assert that we must have a ground pin with the name in our PG pin list
            require_values(self, "related_ground_pin", map(lambda x: x.name, self.cell.ground_pins()))


    def has_attr(self, attr):
        return attr in self.attr.keys()

    # TODO emit timing arcs
    def emit(self):
        output  = "pin (%s) {\n" % self.name
        for k in self.attr:
            output += "    %s : %s;\n" % (k, self.attr[k])
        output += "}\n"
        return output

class PGPin:

    def __init__(self, cell, attr):
        self.cell = cell
        self.attr = attr
        self.name = get_name(self)
        # For now only implement primary power/ground. If anyone needs secondary power/ground, you get to update this!
        require_values(self, "pg_type", ["primary_power", "primary_ground"])
        self.type = self.attr["pg_type"]

    def emit(self):
        output = "pg_pin (%s) {\n" % self.name
        output += indent("pg_type : %s;\n" % self.type)
        # For now assert that voltage_name is the same as the pin name
        output += indent("voltage_name : %s;\n" % self.name)
        output += "}\n"
        return output

def get_name(obj):
    if "name" not in obj.attr.keys():
        sys.stderr.write("Missing name for %s object. Aborting.\n" % obj.__class__.__name__)
        exit(1)
    return obj.attr["name"]

def require_key(obj, key):
    if key not in obj.attr.keys():
        sys.stderr.write("Missing required key \"%s\" for %s object %s. Aborting.\n" % (key, obj.__class__.__name__, obj.name))
        exit(1)

def require_values(obj, key, values):
    require_key(obj, key)
    if obj.attr[key] not in values:
        sys.stderr.write("Invalid entry \"%s\" for attribute \"%s\" of %s object %s. Allowed values are %s. Aborting.\n" % (obj.attr[key], key, obj.__class__.__name__, obj.name, ', '.join(values)))
        exit(1)

def optional_values(obj, key, values, default=None):
    if key in obj.attr:
        require_values(obj, key, values)
    else:
        if default is not None:
            obj.attr[key] = default
            require_values(obj, key, values)

def try_convert_float(obj, key):
    require_key(obj, key)
    try:
        return float(obj.attr[key])
    except:
        sys.stderr.write("Invalid entry %s for attribute %s of %s object %s. Must be a float. Aborting.\n" % (obj.attr[key], key, obj.__class__.__name__, obj.name))
        exit(1)

def try_convert_int(obj, key):
    require_key(obj, key)
    try:
        return int(obj.attr[key])
    except:
        sys.stderr.write("Invalid entry %s for attribute %s of %s object %s. Must be a int. Aborting.\n" % (obj.attr[key], key, obj.__class__.__name__, obj.name))
        exit(1)

def require_float(obj, key):
    try_convert_float(obj, key)

def require_int(obj, key):
    try_convert_int(obj, key)

def indent(s, lvl=1):
    return re.compile('^([^$])',re.MULTILINE).sub(" " * IWIDTH * lvl + "\\1", s)

def __main__():
    libfile = "../conf/test.json"
    try:
        lib_attr = json.load(file(libfile))
    except:
        sys.stderr.write("Syntax error parsing JSON file %s. Aborting.\n" % libfile)
        exit(1)
    cornerfile = "../conf/corners.json"
    try:
        corner_attr = json.load(file(cornerfile))["corners"]
    except:
        sys.stderr.write("Syntax error parsing JSON file %s. Aborting.\n" % cornerfile)
        exit(1)
    lib = Lib(lib_attr, corner_attr)
    print(lib.emit(lib.corners[0]))

__main__()
