#!/usr/bin/env python

import os
import re
import json
import sys
from datetime import datetime

# Define how many spaces are in an indentation
IWIDTH = 4

# Default function to name the .lib, passed to the Library constructor
def default_library_namer(lib, corner):
    return lib.name + "_" + corner.name

def default_file_namer(lib, corner):
    return os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), "output", default_library_namer(lib, corner) + ".lib")

class Corner:

    def __init__(self, attr):
        self.attr = attr
        self.name = get_name(self)
        self.process = try_convert_int(self, "process")
        self.temperature = try_convert_int(self, "temperature")
        require_key(self, "voltage_map")
        require_float(self, "nominal_voltage")
        self.voltage = self.attr["nominal_voltage"]
        self.voltage_map = {}
        for k in self.attr["voltage_map"]:
            self.voltage_map[k] = float(self.attr["voltage_map"][k])

    def emit(self):
        output  = "nom_process : %d;\n" % self.process
        output += "nom_temperature : %d;\n" % self.temperature
        output += "nom_voltage : %f;\n" % self.voltage
        for k in self.voltage_map:
            output += "voltage_map(%s, %f);\n" % (k, self.voltage_map[k])
        output += "operating_conditions(\"%s\") {\n" % self.name
        output += indent("process : %d;\n") % self.process
        output += indent("temperature : %d;\n") % self.temperature
        output += indent("voltage : %f;\n") % self.voltage
        output += "}\n"
        output += "default_operating_conditions : %s;\n" % self.name
        return output

class Library:

    def __init__(self, attr, corners, library_namer=default_library_namer):
        self.attr = attr
        self.name = get_name(self)
        self.datetime = datetime.now().strftime("%c")
        require_int(self,"revision")
        self.corners = []
        for c in corners:
            self.add_corner(c)
        # Check that all corners have the same voltage names
        for c in self.corners:
            if (set(c.voltage_map.keys()) != set(self.voltage_names())):
                sys.stderr.write("Error: all corners must have the same voltage names! Aborting.\n")
                exit(1)
        require_key(self,"cells")
        self.cells = []
        self.library_namer = library_namer
        for a in self.attr["cells"]:
            self.add_cell(a)

    def voltage_names(self):
        return self.corners[0].voltage_map.keys()

    def add_cell(self, cell_attr):
        self.cells.append(Cell(self, cell_attr))

    def add_corner(self, corner_attr):
        self.corners.append(Corner(corner_attr))

    def emit(self, corner):
        output  = "library (%s) {\n" % self.library_namer(self, corner)
        header  = "technology (cmos);\n"
        header += "date : \"%s\";\n" % self.datetime
        header += "comment : \"Generated by dotlibber.py\";\n"
        header += "revision : %s;\n" % self.attr["revision"]
        # Assert that we're only doing NLDM
        header += "delay_model : table_lookup;\n"
        header += "simulation : true;\n"
        # Here are a bunch of unit specs that nobody ever changes.
        header += "capacitive_load_unit : \"1pF\";\n"
        header += "voltage_unit : \"1V\";\n"
        header += "current_unit : \"1mA\";\n"
        header += "time_unit : \"1ns\";\n"
        header += "pulling_resistance_unit : \"1kohm\";\n"
        output += indent(header)
        output += indent(corner.emit())
        output += "\n"
        for c in self.cells:
            output += indent(c.emit())
            output += "\n"

        output += "}\n"
        return output

    def write_all(self, file_namer=default_file_namer):
        for corner in self.corners:
            f = file_namer(self, corner)
            # this is basically mkdir -p
            try:
                os.makedirs(os.path.dirname(f))
            except OSError:
                pass
            open(f,"w").write(self.emit(corner))

class Cell:

    def __init__(self, lib, attr):
        self.lib = lib
        self.attr = attr
        self.name = get_name(self)
        require_key(self, "pg_pins")
        require_key(self, "pins")
        self.pg_pins = []
        self.pins = []
        self.clocks = []
        for p in self.attr["pg_pins"]:
            self.add_pg_pin(p)
        for p in self.attr["pins"]:
            self.add_pin(p)

    def power_pins(self):
        return filter(lambda x: x.type == "primary_power", self.pg_pins)

    def ground_pins(self):
        return filter(lambda x: x.type == "primary_ground", self.pg_pins)

    def add_pg_pin(self, pg_pin_attr):
        self.pg_pins.append(PGPin(self, pg_pin_attr))

    def add_pin(self, pin_attr):
        self.pins.append(Pin(self, pin_attr))

    def add_clock(self, pin):
        self.clocks.append(pin)

    def emit(self):
        output  = "cell (%s) {\n" % self.name
        # For now, always dont_touch, dont_use macros. We aren't using this for std cells.
        output += indent("dont_use : true;\n")
        output += indent("dont_touch : true;\n")
        output += indent("is_macro_cell : true;\n")
        for p in self.pg_pins + self.pins:
            output += "\n"
            output += indent(p.emit())
        output += "}\n"
        return output

class Pin:

    def __init__(self, cell, attr):
        self.cell = cell
        self.attr = attr
        self.name = get_name(self)
        require_values(self, "direction", ["input", "output", "inout"])
        optional_values(self, "is_analog", ["true", "false"], "false")
        optional_values(self, "clock", ["true", "false"], "false")
        # Digital pin checks
        if self.attr["is_analog"] == "false":
            if self.attr["clock"] == "true":
                self.cell.add_clock(self)
            if self.attr["direction"] == "inout":
                sys.stderr.write("Digital inout pins are not supported. FIXME. Aborting\n")
                exit(1)
            require_float(self, "capacitance")
            # Assert that we must have a power pin with the name in our PG pin list
            require_values(self, "related_power_pin", map(lambda x: x.name, self.cell.power_pins()))
            # Assert that we must have a ground pin with the name in our PG pin list
            require_values(self, "related_ground_pin", map(lambda x: x.name, self.cell.ground_pins()))


    def has_attr(self, attr):
        return attr in self.attr.keys()

    # TODO emit timing arcs
    def emit(self):
        output  = "pin (%s) {\n" % self.name
        for k in self.attr:
            output += "    %s : %s;\n" % (k, self.attr[k])
        output += "}\n"
        return output

class PGPin:

    def __init__(self, cell, attr):
        self.cell = cell
        self.attr = attr
        self.name = get_name(self)
        # For now only implement primary power/ground. If anyone needs secondary power/ground, you get to update this!
        require_values(self, "pg_type", ["primary_power", "primary_ground"])
        require_values(self, "name", self.cell.lib.voltage_names())
        self.type = self.attr["pg_type"]

    def emit(self):
        output = "pg_pin (%s) {\n" % self.name
        output += indent("pg_type : %s;\n" % self.type)
        # For now assert that voltage_name is the same as the pin name
        output += indent("voltage_name : %s;\n" % self.name)
        output += "}\n"
        return output

def get_name(obj):
    if "name" not in obj.attr.keys():
        sys.stderr.write("Missing name for %s object. Aborting.\n" % obj.__class__.__name__)
        exit(1)
    return obj.attr["name"]

def require_key(obj, key):
    if key not in obj.attr.keys():
        sys.stderr.write("Missing required key \"%s\" for %s object %s. Aborting.\n" % (key, obj.__class__.__name__, obj.name))
        exit(1)

def require_values(obj, key, values):
    require_key(obj, key)
    if obj.attr[key] not in values:
        sys.stderr.write("Invalid entry \"%s\" for attribute \"%s\" of %s object %s. Allowed values are %s. Aborting.\n" % (obj.attr[key], key, obj.__class__.__name__, obj.name, ', '.join(values)))
        exit(1)

def optional_values(obj, key, values, default=None):
    if key in obj.attr:
        require_values(obj, key, values)
    else:
        if default is not None:
            obj.attr[key] = default
            require_values(obj, key, values)

def try_convert_float(obj, key):
    require_key(obj, key)
    try:
        return float(obj.attr[key])
    except:
        sys.stderr.write("Invalid entry %s for attribute %s of %s object %s. Must be a float. Aborting.\n" % (obj.attr[key], key, obj.__class__.__name__, obj.name))
        exit(1)

def try_convert_int(obj, key):
    require_key(obj, key)
    try:
        return int(obj.attr[key])
    except:
        sys.stderr.write("Invalid entry %s for attribute %s of %s object %s. Must be a int. Aborting.\n" % (obj.attr[key], key, obj.__class__.__name__, obj.name))
        exit(1)

def require_float(obj, key):
    try_convert_float(obj, key)

def require_int(obj, key):
    try_convert_int(obj, key)

def indent(s, lvl=1):
    return re.compile('^([^\n])',re.MULTILINE).sub(" " * IWIDTH * lvl + "\\1", s)

def read_library_json(libfile, cornerfile, library_namer=default_library_namer):
    try:
        lib_attr = json.load(file(libfile))
    except:
        sys.stderr.write("Syntax error parsing JSON file %s. Aborting.\n" % libfile)
        exit(1)
    try:
        corner_attr = json.load(file(cornerfile))["corners"]
    except:
        sys.stderr.write("Syntax error parsing JSON file %s. Aborting.\n" % cornerfile)
        exit(1)
    return Library(lib_attr, corner_attr, library_namer)

def main():
    read_library_json("../conf/test.json", "../conf/corners.json").write_all()

if __name__ == "__main__":
    main()
